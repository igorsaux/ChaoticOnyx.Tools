using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using YamlDotNet.Core;
using YamlDotNet.Serialization;
using YamlDotNet.Serialization.Converters;
using YamlDotNet.Serialization.NamingConventions;

namespace ChaoticOnyx.Tools.ChangelogGenerator.Parsers
{
	[ChangelogParser(".yml")]
	public sealed class YamlChangelogParser : ChangelogParser
	{
		private readonly List<Func<string, ICollection<Changelog>>> _cacheConverters;
		private readonly List<Func<string, Changelog>>              _changelogConverters;
		private readonly IDeserializer                              _deserializer;
		private readonly ISerializer                                _serializer;

		public YamlChangelogParser()
		{
			string            format            = CultureInfo.InvariantCulture.DateTimeFormat.ShortDatePattern;
			DateTimeConverter dateTimeConverter = new(DateTimeKind.Local, CultureInfo.InvariantCulture, format);

			_deserializer = new DeserializerBuilder().IgnoreUnmatchedProperties()
													 .WithNamingConvention(CamelCaseNamingConvention.Instance)
													 .Build();

			_serializer = new SerializerBuilder().WithTypeConverter(dateTimeConverter)
												 .WithNamingConvention(CamelCaseNamingConvention.Instance)
												 .Build();

			_changelogConverters = new List<Func<string, Changelog>> { ChaoticOnyxChangelog, VgChangelogToChaoticOnyx };

			_cacheConverters = new List<Func<string, ICollection<Changelog>>>
			{
				ChaoticOnyxCache, VgCacheToChaoticOnyx
			};
		}

		public override Changelog Parse(string text)
		{
			Changelog? result = null;

			for (var i = 0; i < _changelogConverters.Count; i++)
			{
				Func<string, Changelog>? converter = _changelogConverters[i];

				try
				{
					result = converter.Invoke(text);

					return result;
				}
				catch (YamlException)
				{
					if (i == _changelogConverters.Count - 1) { throw; }
				}
			}

			Debug.Assert(result != null);

			return result;
		}

		public override ICollection<Changelog> ParseCache(string text)
		{
			ICollection<Changelog>? result = null;

			for (var i = 0; i < _cacheConverters.Count; i++)
			{
				Func<string, ICollection<Changelog>>? converter = _cacheConverters[i];

				try
				{
					result = converter.Invoke(text);

					return result;
				}
				catch (YamlException)
				{
					if (i == _cacheConverters.Count - 1) { throw; }
				}
			}

			Debug.Assert(result != null);

			return result;
		}

		public override string SerializeCache(ICollection<Changelog> cache) { return _serializer.Serialize(cache); }

		private ICollection<Changelog> VgCacheToChaoticOnyx(string text)
		{
			text = text.Replace("DO NOT EDIT THIS FILE BY HAND!  AUTOMATICALLY GENERATED BY ss13_genchangelog.py.", "");
			text = text.Replace("---", "");

			Dictionary<DateTime, Dictionary<string, List<Dictionary<string, string>>>> cache = _deserializer
				.Deserialize<Dictionary<DateTime, Dictionary<string, List<Dictionary<string, string>>>>>(text);

			var changelogs = new List<Changelog>();

			foreach ((DateTime date, var authors) in cache)
			{
				foreach (var (author, changes) in authors)
				{
					List<Change> changesList = new();

					foreach (var change in changes)
					{
						foreach (var (prefix, message) in change) { changesList.Add(new Change(prefix, message)); }
					}

					var changelog = new Changelog(author, date, changesList);
					changelogs.Add(changelog);
				}
			}

			return changelogs;
		}

		private ICollection<Changelog> ChaoticOnyxCache(string text)
		{
			ICollection<Changelog> result = _deserializer.Deserialize<ICollection<Changelog>>(text);

			return result;
		}

		private Changelog ChaoticOnyxChangelog(string text) { return _deserializer.Deserialize<Changelog>(text); }

		private Changelog VgChangelogToChaoticOnyx(string text)
		{
			VgChangelog  parsed  = _deserializer.Deserialize<VgChangelog>(text);
			List<Change> changes = new();

			foreach (var e in parsed.Changes)
			{
				foreach (var (prefix, message) in e) { changes.Add(new Change(prefix, message)); }
			}

			return new Changelog(parsed.Author, DateTime.Now, changes);
		}

		private sealed record VgChangelog
		{
			public string Author { get; init; }

			public List<Dictionary<string, string>> Changes { get; init; }
		}
	}
}
